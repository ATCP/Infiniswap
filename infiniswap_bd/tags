!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACTIVITY	infiniswap.h	/^		ACTIVITY,$/;"	e	enum:IS_rdma_info::__anon2
ADDR_RESOLVED	infiniswap.h	/^	ADDR_RESOLVED,$/;"	e	enum:test_state
AFTER_FREE_MEM	infiniswap.h	/^	AFTER_FREE_MEM,$/;"	e	enum:test_state
BACKUP_DISK	infiniswap.h	204;"	d
BACKUP_DISK	infiniswap.h	206;"	d
BIND	infiniswap.h	/^		BIND,$/;"	e	enum:IS_rdma_info::__anon2
BIND_SINGLE	infiniswap.h	/^		BIND_SINGLE,$/;"	e	enum:IS_rdma_info::__anon2
BIO_PAGE_CAP	infiniswap.h	211;"	d
BIO_PAGE_CAP	infiniswap.h	213;"	d
BITMAP_INT_SIZE	infiniswap.h	255;"	d
BITMAP_MASK	infiniswap.h	252;"	d
BITMAP_SHIFT	infiniswap.h	250;"	d
CB_CONNECTED	infiniswap.h	/^	CB_CONNECTED,	\/\/connected but not mapped $/;"	e	enum:cb_state
CB_EVICTING	infiniswap.h	/^	CB_EVICTING,$/;"	e	enum:cb_state
CB_FAIL	infiniswap.h	/^	CB_FAIL$/;"	e	enum:cb_state
CB_IDLE	infiniswap.h	/^	CB_IDLE=0,$/;"	e	enum:cb_state
CB_MAPPED	infiniswap.h	/^	CB_MAPPED,$/;"	e	enum:cb_state
CHUNK_MAPPED	infiniswap.h	321;"	d
CHUNK_UNMAPPED	infiniswap.h	322;"	d
CM_DISCONNECT	infiniswap.h	/^	CM_DISCONNECT,$/;"	e	enum:test_state
CONFIGDIR	nbdxadm/nbdxadm	/^CONFIGDIR = '\/etc\/infiniswap'$/;"	v
CONFIGFILE	nbdxadm/nbdxadm	/^CONFIGFILE = os.path.join(CONFIGDIR, 'infiniswap.ini')$/;"	v
CONFIGFS	nbdxadm/nbdxadm	/^CONFIGFS = '\/sys\/kernel\/config'$/;"	v
CONNECTED	infiniswap.h	/^	CONNECTED,		\/\/ updated by IS_cma_event_handler()$/;"	e	enum:test_state
CONNECT_REQUEST	infiniswap.h	/^	CONNECT_REQUEST,$/;"	e	enum:test_state
CTX_IDLE	infiniswap.h	436;"	d
CTX_R_IN_FLIGHT	infiniswap.h	437;"	d
CTX_W_IN_FLIGHT	infiniswap.h	438;"	d
C_EVICT	infiniswap.h	/^	C_EVICT,$/;"	e	enum:chunk_list_state
C_IDLE	infiniswap.h	/^	C_IDLE,$/;"	e	enum:chunk_list_state
C_READY	infiniswap.h	/^	C_READY,$/;"	e	enum:chunk_list_state
C_STOP	infiniswap.h	/^	C_STOP,$/;"	e	enum:chunk_list_state
DEVICE_INITIALIZING	infiniswap.h	/^	DEVICE_INITIALIZING,$/;"	e	enum:IS_dev_state
DEVICE_OFFLINE	infiniswap.h	/^	DEVICE_OFFLINE$/;"	e	enum:IS_dev_state
DEVICE_OPENNING	infiniswap.h	/^	DEVICE_OPENNING,$/;"	e	enum:IS_dev_state
DEVICE_RUNNING	infiniswap.h	/^	DEVICE_RUNNING,$/;"	e	enum:IS_dev_state
DEV_RDMA_OFF	infiniswap.h	510;"	d
DEV_RDMA_ON	infiniswap.h	509;"	d
DMA	infiniswap.h	/^	DMA = 1,$/;"	e	enum:mem_type
DONE	infiniswap.h	/^		DONE = 1,$/;"	e	enum:IS_rdma_info::__anon2
DRV_NAME	is_main.c	44;"	d	file:
DRV_VERSION	is_main.c	/^MODULE_VERSION(DRV_VERSION);$/;"	v
DRV_VERSION	is_main.c	46;"	d	file:
ERROR	infiniswap.h	/^	ERROR$/;"	e	enum:test_state
EVICT	infiniswap.h	/^		EVICT,$/;"	e	enum:IS_rdma_info::__anon2
FASTREG	infiniswap.h	/^	FASTREG = 2,$/;"	e	enum:mem_type
FREE_MEM_RECV	infiniswap.h	/^	FREE_MEM_RECV,$/;"	e	enum:test_state
FREE_SIZE	infiniswap.h	/^		FREE_SIZE,$/;"	e	enum:IS_rdma_info::__anon2
HAVE_LOOKUP_BDEV_PATCH	config.h	6;"	d
IDLE	infiniswap.h	/^	IDLE = 1,$/;"	e	enum:test_state
INFINISWAP_H	infiniswap.h	43;"	d
INFO	infiniswap.h	/^		INFO,$/;"	e	enum:IS_rdma_info::__anon2
INFO_SINGLE	infiniswap.h	/^		INFO_SINGLE,$/;"	e	enum:IS_rdma_info::__anon2
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INT_BITS	infiniswap.h	249;"	d
IS_PAGE_SIZE	infiniswap.h	311;"	d
IS_QUEUE_DEPTH	infiniswap.h	193;"	d
IS_SECT_SHIFT	infiniswap.h	192;"	d
IS_SECT_SIZE	infiniswap.h	191;"	d
IS_alloc_hctx	is_mq.c	/^static struct blk_mq_hw_ctx *IS_alloc_hctx(struct blk_mq_reg *reg,$/;"	f	file:
IS_bind_client	is_main.c	/^static int IS_bind_client(struct kernel_cb *cb)$/;"	f	file:
IS_bitmap_clear	is_mq.c	/^void IS_bitmap_clear(int *bitmap, int i)$/;"	f
IS_bitmap_group_clear	is_mq.c	/^void IS_bitmap_group_clear(int *bitmap, unsigned long offset, unsigned long len)$/;"	f
IS_bitmap_group_set	is_mq.c	/^void IS_bitmap_group_set(int *bitmap, unsigned long offset, unsigned long len)$/;"	f
IS_bitmap_init	is_mq.c	/^void IS_bitmap_init(int *bitmap)$/;"	f
IS_bitmap_set	is_mq.c	/^void IS_bitmap_set(int *bitmap, int i)$/;"	f
IS_bitmap_test	is_mq.c	/^bool IS_bitmap_test(int *bitmap, int i)$/;"	f
IS_chunk_list_init	is_mq.c	/^void IS_chunk_list_init(struct kernel_cb *cb)$/;"	f
IS_chunk_wait_in_flight_requests	is_main.c	/^static int IS_chunk_wait_in_flight_requests(struct kernel_cb *cb)$/;"	f	file:
IS_cleanup_module	is_main.c	/^module_exit(IS_cleanup_module);$/;"	v
IS_cleanup_module	is_main.c	/^static void __exit IS_cleanup_module(void)$/;"	f	file:
IS_cma_event_handler	is_main.c	/^static int IS_cma_event_handler(struct rdma_cm_id *cma_id,$/;"	f	file:
IS_conn	infiniswap.h	/^	struct IS_connection	    *IS_conn;$/;"	m	struct:IS_queue	typeref:struct:IS_queue::IS_connection
IS_conn	infiniswap.h	/^	struct IS_connection *IS_conn;$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::IS_connection
IS_connect_client	is_main.c	/^static int IS_connect_client(struct kernel_cb *cb)$/;"	f	file:
IS_connection	infiniswap.h	/^struct IS_connection {$/;"	s
IS_conns	infiniswap.h	/^	struct IS_connection	    **IS_conns;$/;"	m	struct:IS_file	typeref:struct:IS_file::IS_connection
IS_conns	infiniswap.h	/^	struct IS_connection	    **IS_conns;$/;"	m	struct:IS_session	typeref:struct:IS_session::IS_connection
IS_create_configfs_files	is_configfs.c	/^int IS_create_configfs_files(void)$/;"	f
IS_create_conn	is_main.c	/^static int IS_create_conn(struct IS_session *IS_session, int cpu,$/;"	f	file:
IS_create_device	is_main.c	/^int IS_create_device(struct IS_session *IS_session,$/;"	f
IS_create_qp	is_main.c	/^static int IS_create_qp(struct kernel_cb *cb)$/;"	f	file:
IS_ctx_dma_setup	is_main.c	/^void IS_ctx_dma_setup(struct kernel_cb *cb, struct IS_session *IS_session, int cb_index)$/;"	f
IS_ctx_init	is_main.c	/^static int IS_ctx_init(struct IS_connection *IS_conn, struct kernel_cb *cb, int cb_index)$/;"	f	file:
IS_destroy_configfs_files	is_configfs.c	/^void IS_destroy_configfs_files(void)$/;"	f
IS_destroy_conn	is_main.c	/^static void IS_destroy_conn(struct IS_connection *IS_conn)$/;"	f	file:
IS_destroy_device	is_main.c	/^void IS_destroy_device(struct IS_session *IS_session,$/;"	f
IS_destroy_queues	is_mq.c	/^void IS_destroy_queues(struct IS_file *xdev)$/;"	f
IS_destroy_session_devices	is_main.c	/^static void IS_destroy_session_devices(struct IS_session *IS_session)$/;"	f	file:
IS_dev_state	infiniswap.h	/^enum IS_dev_state {$/;"	g
IS_device_drop	is_configfs.c	/^static void IS_device_drop(struct config_group *group, struct config_item *item)$/;"	f	file:
IS_device_item_attrs	is_configfs.c	/^static struct configfs_attribute *IS_device_item_attrs[] = {$/;"	v	typeref:struct:configfs_attribute	file:
IS_device_item_ops	is_configfs.c	/^static struct configfs_item_operations IS_device_item_ops = {$/;"	v	typeref:struct:configfs_item_operations	file:
IS_device_make_group	is_configfs.c	/^static struct config_group *IS_device_make_group(struct config_group *group,$/;"	f	file:
IS_device_state_str	is_main.c	/^const char *IS_device_state_str(struct IS_file *dev)$/;"	f
IS_device_type	is_configfs.c	/^static struct config_item_type IS_device_type = {$/;"	v	typeref:struct:config_item_type	file:
IS_disconnect_handler	is_main.c	/^static int IS_disconnect_handler(struct kernel_cb *cb)$/;"	f	file:
IS_file	infiniswap.h	/^struct IS_file {$/;"	s
IS_file_find	is_main.c	/^struct IS_file *IS_file_find(struct IS_session *IS_session,$/;"	f
IS_free_buffers	is_main.c	/^static void IS_free_buffers(struct kernel_cb *cb)$/;"	f	file:
IS_free_hctx	is_mq.c	/^static void IS_free_hctx(struct blk_mq_hw_ctx *hctx, unsigned int hctx_index)$/;"	f	file:
IS_free_qp	is_main.c	/^static void IS_free_qp(struct kernel_cb *cb)$/;"	f	file:
IS_get_ctx	is_main.c	/^static struct rdma_ctx *IS_get_ctx(struct ctx_pool_list *tmp_pool)$/;"	f	file:
IS_group_ops	is_configfs.c	/^static struct configfs_group_operations IS_group_ops = {$/;"	v	typeref:struct:configfs_group_operations	file:
IS_indexes	is_main.c	/^int IS_indexes; \/* num of devices created*\/$/;"	v
IS_init_hctx	is_mq.c	/^static int IS_init_hctx(struct blk_mq_hw_ctx *hctx, void *data,$/;"	f	file:
IS_init_module	is_main.c	/^module_init(IS_init_module);$/;"	v
IS_init_module	is_main.c	/^static int __init IS_init_module(void)$/;"	f	file:
IS_insert_ctx	is_main.c	/^void IS_insert_ctx(struct rdma_ctx *ctx)$/;"	f
IS_ioctl	is_mq.c	/^static int IS_ioctl(struct block_device *bd, fmode_t mode,$/;"	f	file:
IS_item	is_configfs.c	/^static struct config_item_type IS_item = {$/;"	v	typeref:struct:config_item_type	file:
IS_major	is_main.c	/^int IS_major;$/;"	v
IS_media_changed	is_mq.c	/^static int IS_media_changed(struct gendisk *gd)$/;"	f	file:
IS_mq_ops	is_mq.c	/^static struct blk_mq_ops IS_mq_ops = {$/;"	v	typeref:struct:blk_mq_ops	file:
IS_mq_reg	is_mq.c	/^static struct blk_mq_reg IS_mq_reg = {$/;"	v	typeref:struct:blk_mq_reg	file:
IS_mq_request_stackbd	is_mq.c	/^void IS_mq_request_stackbd(struct request *req)$/;"	f
IS_mq_request_stackbd2	is_mq.c	/^void IS_mq_request_stackbd2(struct request *req)$/;"	f
IS_open	is_mq.c	/^static int IS_open(struct block_device *bd, fmode_t mode)$/;"	f	file:
IS_ops	is_mq.c	/^static struct block_device_operations IS_ops = {$/;"	v	typeref:struct:block_device_operations	file:
IS_portal	infiniswap.h	/^struct IS_portal {$/;"	s
IS_queue	infiniswap.h	/^struct IS_queue {$/;"	s
IS_queue_rq	is_mq.c	/^static int IS_queue_rq(struct blk_mq_hw_ctx *hctx, const struct blk_mq_queue_data *bd)$/;"	f	file:
IS_rdma_info	infiniswap.h	/^struct IS_rdma_info {$/;"	s
IS_rdma_read	is_main.c	/^int IS_rdma_read(struct IS_connection *IS_conn, struct kernel_cb *cb, int cb_index, int chunk_index, struct remote_chunk_g *chunk, unsigned long offset, unsigned long len, struct request *req, struct IS_queue *q)$/;"	f
IS_rdma_write	is_main.c	/^int IS_rdma_write(struct IS_connection *IS_conn, struct kernel_cb *cb, int cb_index, int chunk_index, struct remote_chunk_g *chunk, unsigned long offset, unsigned long len, struct request *req, struct IS_queue *q)$/;"	f
IS_register_block_device	is_mq.c	/^int IS_register_block_device(struct IS_file *IS_file)$/;"	f
IS_release	is_mq.c	/^static void IS_release(struct gendisk *gd, fmode_t mode)$/;"	f	file:
IS_request	is_mq.c	/^static int IS_request(struct request *req, struct IS_queue *xq)$/;"	f	file:
IS_revalidate	is_mq.c	/^static int IS_revalidate(struct gendisk *gd)$/;"	f	file:
IS_send_activity	is_main.c	/^static int IS_send_activity(struct kernel_cb *cb)$/;"	f	file:
IS_send_bind_single	is_main.c	/^static int IS_send_bind_single(struct kernel_cb *cb, int select_chunk)$/;"	f	file:
IS_send_done	is_main.c	/^static int IS_send_done(struct kernel_cb *cb, int num)$/;"	f	file:
IS_send_query	is_main.c	/^static int IS_send_query(struct kernel_cb *cb)$/;"	f	file:
IS_sess	infiniswap.h	/^	struct IS_session    *IS_sess;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::IS_session
IS_sess	infiniswap.h	/^	struct IS_session *IS_sess;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::IS_session
IS_session	infiniswap.h	/^struct IS_session {$/;"	s
IS_session_create	is_main.c	/^int IS_session_create(const char *portal, struct IS_session *IS_session)$/;"	f
IS_session_destroy	is_main.c	/^void IS_session_destroy(struct IS_session *IS_session)$/;"	f
IS_session_devices_group_ops	is_configfs.c	/^static struct configfs_group_operations IS_session_devices_group_ops = {$/;"	v	typeref:struct:configfs_group_operations	file:
IS_session_drop	is_configfs.c	/^static void IS_session_drop(struct config_group *group, struct config_item *item)$/;"	f	file:
IS_session_find_by_portal	is_main.c	/^struct IS_session *IS_session_find_by_portal(struct list_head *s_data_list,$/;"	f
IS_session_item_attrs	is_configfs.c	/^static struct configfs_attribute *IS_session_item_attrs[] = {$/;"	v	typeref:struct:configfs_attribute	file:
IS_session_item_ops	is_configfs.c	/^static struct configfs_item_operations IS_session_item_ops = {$/;"	v	typeref:struct:configfs_item_operations	file:
IS_session_make_group	is_configfs.c	/^static struct config_group *IS_session_make_group(struct config_group *group,$/;"	f	file:
IS_session_type	is_configfs.c	/^static struct config_item_type IS_session_type = {$/;"	v	typeref:struct:config_item_type	file:
IS_set_device_state	is_main.c	/^inline int IS_set_device_state(struct IS_file *xdev,$/;"	f
IS_setup_buffers	is_main.c	/^static int IS_setup_buffers(struct kernel_cb *cb)$/;"	f	file:
IS_setup_qp	is_main.c	/^static int IS_setup_qp(struct kernel_cb *cb, struct rdma_cm_id *cm_id)$/;"	f	file:
IS_setup_queues	is_mq.c	/^int IS_setup_queues(struct IS_file *xdev)$/;"	f
IS_setup_wr	is_main.c	/^static void IS_setup_wr(struct kernel_cb *cb)$/;"	f	file:
IS_single_chunk_init	is_mq.c	/^void IS_single_chunk_init(struct kernel_cb *cb)$/;"	f
IS_single_chunk_map	is_main.c	/^int IS_single_chunk_map(struct IS_session *IS_session, int select_chunk)$/;"	f
IS_stackbd_end_io	is_mq.c	/^void IS_stackbd_end_io(struct bio *bio, int err)$/;"	f
IS_stackbd_end_io2	is_mq.c	/^void IS_stackbd_end_io2(struct bio *bio, int err)$/;"	f
IS_stackbd_end_io3	is_mq.c	/^void IS_stackbd_end_io3(struct bio *bio, int err)$/;"	f
IS_subsys	is_configfs.c	/^static struct configfs_subsystem IS_subsys = {$/;"	v	typeref:struct:configfs_subsystem	file:
IS_transfer_chunk	is_main.c	/^int IS_transfer_chunk(struct IS_file *xdev, struct kernel_cb *cb, int cb_index, int chunk_index, struct remote_chunk_g *chunk, unsigned long offset,$/;"	f
IS_unregister_block_device	is_mq.c	/^void IS_unregister_block_device(struct IS_file *IS_file)$/;"	f
KERNEL_SECTOR_SIZE	infiniswap.h	220;"	d
KSYMVERS	Makefile	/^KSYMVERS = \/home\/liuke\/Infiniswap\/infiniswap_bd\/Module.symvers \/var\/lib\/dkms\/mlnx-ofed-kernel\/4.1\/build\/Module.symvers$/;"	m
LAST_IN_BATCH	infiniswap.h	144;"	d
LOGICAL_BLOCK_SIZE	infiniswap.h	/^static int LOGICAL_BLOCK_SIZE = 512;$/;"	v
LOOKUP_BDEV	is_mq.c	50;"	d	file:
LOOKUP_BDEV	is_mq.c	52;"	d	file:
MAX_IS_DEV_NAME	infiniswap.h	188;"	d
MAX_MR_SIZE_GB	infiniswap.h	266;"	d
MAX_MR_SIZE_GB	infiniswap.h	268;"	d
MAX_MSG_LEN	infiniswap.h	186;"	d
MAX_PORTAL_NAME	infiniswap.h	187;"	d
MAX_SGL_LEN	infiniswap.h	151;"	d
MAX_SGL_LEN	infiniswap.h	154;"	d
MAX_SGL_LEN	infiniswap.h	156;"	d
MR	infiniswap.h	/^	MR = 4$/;"	e	enum:mem_type
MW	infiniswap.h	/^	MW = 3,$/;"	e	enum:mem_type
NBDX_CONFIGFS	nbdxadm/nbdxadm	/^NBDX_CONFIGFS = os.path.join(CONFIGFS, 'infiniswap')$/;"	v
NO_CB_MAPPED	infiniswap.h	574;"	d
NUM_CB	is_main.c	/^int NUM_CB;	\/\/ num of server\/cb$/;"	v
OFED_CFLAGS	Makefile	/^OFED_CFLAGS = -I\/var\/lib\/dkms\/mlnx-ofed-kernel\/4.1\/build\/include -include \/var\/lib\/dkms\/mlnx-ofed-kernel\/4.1\/build\/include\/linux\/compat-2.6.h$/;"	m
ONE_GB	infiniswap.h	254;"	d
ONE_GB_MASK	infiniswap.h	253;"	d
ONE_GB_SHIFT	infiniswap.h	251;"	d
PACKAGE_BUGREPORT	config.h	9;"	d
PACKAGE_NAME	config.h	12;"	d
PACKAGE_STRING	config.h	15;"	d
PACKAGE_TARNAME	config.h	18;"	d
PACKAGE_URL	config.h	21;"	d
PACKAGE_VERSION	config.h	24;"	d
PFX	is_main.c	45;"	d	file:
QUERY	infiniswap.h	/^		QUERY$/;"	e	enum:IS_rdma_info::__anon2
QUEUE_NUM_MASK	infiniswap.h	194;"	d
RDMA_BUF_ADV	infiniswap.h	/^	RDMA_BUF_ADV,   \/\/ designed for server$/;"	e	enum:test_state
RDMA_CUR_WEIGHT	infiniswap.h	572;"	d
RDMA_DONE	infiniswap.h	/^	RDMA_DONE,$/;"	e	enum:test_state
RDMA_READ_ADV	infiniswap.h	/^	RDMA_READ_ADV,	\/\/ updated by IS_cq_event_handler()$/;"	e	enum:test_state
RDMA_READ_RUNNING	infiniswap.h	/^	RDMA_READ_RUNNING,$/;"	e	enum:test_state
RDMA_TRIGGER_PERIOD	infiniswap.h	569;"	d
RDMA_TRIGGER_THRESHOLD	infiniswap.h	570;"	d
RDMA_WRITE_ADV	infiniswap.h	/^	RDMA_WRITE_ADV,$/;"	e	enum:test_state
RDMA_WRITE_RUNNING	infiniswap.h	/^	RDMA_WRITE_RUNNING,$/;"	e	enum:test_state
RDMA_W_WEIGHT	infiniswap.h	571;"	d
RECV_EVICT	infiniswap.h	/^	RECV_EVICT,$/;"	e	enum:test_state
RECV_STOP	infiniswap.h	/^	RECV_STOP,$/;"	e	enum:test_state
ROUTE_RESOLVED	infiniswap.h	/^	ROUTE_RESOLVED,$/;"	e	enum:test_state
RUN_OPERATION	nbdxadm/nbdxadm	/^RUN_OPERATION = {'create_host': createHost,$/;"	v
SEND_DONE	infiniswap.h	/^	SEND_DONE,$/;"	e	enum:test_state
SERVER_SELECT_NUM	infiniswap.h	514;"	d
SERVER_SELECT_NUM	infiniswap.h	516;"	d
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
STACKBD_BDEV_MODE	infiniswap.h	219;"	d
STACKBD_DO_IT	infiniswap.h	221;"	d
STACKBD_NAME	infiniswap.h	223;"	d
STACKBD_NAME	infiniswap.h	225;"	d
STACKBD_NAME_0	infiniswap.h	227;"	d
STACKBD_REDIRECT_OFF	infiniswap.h	217;"	d
STACKBD_REDIRECT_ON	infiniswap.h	218;"	d
STACKBD_SIZE_G	infiniswap.h	198;"	d
STACKBD_SIZE_G	infiniswap.h	200;"	d
STAT_BLOCK_SIZE	infiniswap.h	102;"	d
STOP	infiniswap.h	/^		STOP,$/;"	e	enum:IS_rdma_info::__anon2
SUBMIT_BLOCK_SIZE	infiniswap.h	96;"	d
SUBMIT_HEADER_SIZE	infiniswap.h	146;"	d
SUPPORTED_DISKS	infiniswap.h	189;"	d
SUPPORTED_PORTALS	infiniswap.h	190;"	d
TRIGGER_OFF	infiniswap.h	567;"	d
TRIGGER_ON	infiniswap.h	566;"	d
USER_BACKUP_DISK	config.h	27;"	d
USER_BIO_PAGE_CAP	config.h	30;"	d
USER_MAX_PAGE_NUM	config.h	34;"	d
USER_MAX_REMOTE_MEMORY	config.h	38;"	d
USER_NUM_SERVER_SELECT	config.h	42;"	d
USER_STACKBD_NAME	config.h	45;"	d
USER_STACKBD_SIZE	config.h	48;"	d
VERSION	Makefile	/^VERSION = 0.1$/;"	m
WAIT_OPS	infiniswap.h	/^	WAIT_OPS,$/;"	e	enum:test_state
__author__	nbdxadm/nbdxadm	/^__author__ = "Max Gurtovoy"$/;"	v
__version__	nbdxadm/nbdxadm	/^__version__ = '2.0'$/;"	v
addr	infiniswap.h	/^	u8 addr[16];			\/* dst addr in NBO *\/$/;"	m	struct:IS_portal
addr	infiniswap.h	/^	u8 addr[16];			\/* dst addr in NBO *\/$/;"	m	struct:kernel_cb
addr_str	infiniswap.h	/^	char *addr_str;			\/* dst addr string *\/$/;"	m	struct:kernel_cb
addr_type	infiniswap.h	/^	uint8_t addr_type;		\/* ADDR_FAMILY - IPv4\/V6 *\/$/;"	m	struct:kernel_cb
ans	infiniswap.h	/^	struct raio_answer		ans;$/;"	m	struct:raio_io_u	typeref:struct:raio_io_u::raio_answer
as_fn_append	config.status	/^  as_fn_append ()$/;"	f
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	config.status	/^  as_fn_arith ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	config.status	/^as_fn_error ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_executable_p	config.status	/^as_fn_executable_p ()$/;"	f
as_fn_executable_p	configure	/^as_fn_executable_p ()$/;"	f
as_fn_exit	config.status	/^as_fn_exit ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	config.status	/^as_fn_mkdir_p ()$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	config.status	/^as_fn_set_status ()$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	config.status	/^as_fn_unset ()$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
bdev_raw	infiniswap.h	/^    struct block_device *bdev_raw;$/;"	m	struct:stackbd_t	typeref:struct:stackbd_t::block_device
bio_list	infiniswap.h	/^    struct bio_list bio_list;$/;"	m	struct:stackbd_t	typeref:struct:stackbd_t::bio_list
bitmap_g	infiniswap.h	/^	int *bitmap_g;	\/\/1GB bitmap$/;"	m	struct:remote_chunk_g
bitmap_value	is_main.c	/^uint32_t bitmap_value(int *bitmap)$/;"	f
breq	infiniswap.h	/^	struct request		       *breq;$/;"	m	struct:raio_io_u	typeref:struct:raio_io_u::request
buf	infiniswap.h	/^	void			*buf;$/;"	m	struct:raio_iocb_common
buf	infiniswap.h	/^  	uint64_t buf[MAX_MR_SIZE_GB];$/;"	m	struct:IS_rdma_info
build_dir	Makefile	/^build_dir = \/lib\/modules\/$(shell uname -r)$/;"	m
c	infiniswap.h	/^		struct raio_iocb_common	c;$/;"	m	union:raio_iocb::__anon1	typeref:struct:raio_iocb::__anon1::raio_iocb_common
c_state	infiniswap.h	/^	enum chunk_list_state c_state;$/;"	m	struct:remote_chunk_g_list	typeref:enum:remote_chunk_g_list::chunk_list_state
capacity	infiniswap.h	/^	unsigned long long    capacity;$/;"	m	struct:IS_session
capacity	infiniswap.h	/^    sector_t capacity; $/;"	m	struct:stackbd_t
capacity_g	infiniswap.h	/^	int 	capacity_g;$/;"	m	struct:IS_session
cb	infiniswap.h	/^	struct kernel_cb *cb;$/;"	m	struct:chunk_write	typeref:struct:chunk_write::kernel_cb
cb	infiniswap.h	/^	struct kernel_cb *cb;$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::kernel_cb
cb_index	infiniswap.h	/^	int cb_index; \/\/index in IS_sess->cb_list$/;"	m	struct:kernel_cb
cb_index	infiniswap.h	/^	int cb_index;$/;"	m	struct:chunk_write
cb_index_map	infiniswap.h	/^	atomic_t 	*cb_index_map;  \/\/unmapped==-1, this chunk is mapped to which cb$/;"	m	struct:IS_session
cb_list	infiniswap.h	/^	struct kernel_cb	**cb_list;	$/;"	m	struct:IS_session	typeref:struct:IS_session::kernel_cb
cb_num	infiniswap.h	/^	int cb_num;	\/\/num of possible servers$/;"	m	struct:IS_session
cb_state	infiniswap.h	/^enum cb_state {$/;"	g
cb_state_list	infiniswap.h	/^	enum cb_state *cb_state_list; \/\/all cbs state: not used, connected, failure$/;"	m	struct:IS_session	typeref:enum:IS_session::cb_state
cbs	infiniswap.h	/^	struct kernel_cb		**cbs;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::kernel_cb
cgroup_to_IS_device	is_configfs.c	46;"	d	file:
cgroup_to_IS_session	is_configfs.c	45;"	d	file:
child_cm_id	infiniswap.h	/^	struct rdma_cm_id *child_cm_id;	\/* connection on client side,*\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::rdma_cm_id
chunk	infiniswap.h	/^	struct remote_chunk_g *chunk;	$/;"	m	struct:chunk_write	typeref:struct:chunk_write::remote_chunk_g
chunk_index	infiniswap.h	/^	int chunk_index;$/;"	m	struct:chunk_write
chunk_index	infiniswap.h	/^	int chunk_index;$/;"	m	struct:rdma_ctx
chunk_list	infiniswap.h	/^	struct remote_chunk_g **chunk_list;$/;"	m	struct:remote_chunk_g_list	typeref:struct:remote_chunk_g_list::remote_chunk_g
chunk_list_state	infiniswap.h	/^enum chunk_list_state {$/;"	g
chunk_map	infiniswap.h	/^	int *chunk_map;	\/\/cb_chunk_index to session_chunk_index$/;"	m	struct:remote_chunk_g_list
chunk_map_cb_chunk	infiniswap.h	/^	int *chunk_map_cb_chunk; \/\/sess->chunk map to cb-chunk$/;"	m	struct:IS_session
chunk_offset	infiniswap.h	/^	unsigned long chunk_offset;$/;"	m	struct:chunk_write
chunk_ptr	infiniswap.h	/^	struct remote_chunk_g *chunk_ptr;$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::remote_chunk_g
chunk_size_g	infiniswap.h	/^	int chunk_size_g; \/\/size = chunk_num * ONE_GB$/;"	m	struct:remote_chunk_g_list
chunk_write	infiniswap.h	/^struct chunk_write{$/;"	s
client_read_done	is_main.c	/^static int client_read_done(struct kernel_cb * cb, struct ib_wc *wc)$/;"	f	file:
client_recv	is_main.c	/^static int client_recv(struct kernel_cb *cb, struct ib_wc *wc)$/;"	f	file:
client_recv_evict	is_main.c	/^static void client_recv_evict(struct kernel_cb *cb) $/;"	f	file:
client_recv_stop	is_main.c	/^static void client_recv_stop(struct kernel_cb *cb)$/;"	f	file:
client_send	is_main.c	/^static int client_send(struct kernel_cb *cb, struct ib_wc *wc)$/;"	f	file:
client_write_done	is_main.c	/^static int client_write_done(struct kernel_cb * cb, struct ib_wc *wc)$/;"	f	file:
cm_id	infiniswap.h	/^	struct rdma_cm_id *cm_id;	\/* connection on client side,*\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::rdma_cm_id
command	infiniswap.h	/^	uint32_t command;$/;"	m	struct:raio_answer
command	infiniswap.h	/^	uint32_t command;$/;"	m	struct:raio_command
conn_th	infiniswap.h	/^	struct task_struct     *conn_th;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::task_struct
conns_count	infiniswap.h	/^	atomic_t		      conns_count;$/;"	m	struct:IS_session
conns_wait	infiniswap.h	/^	struct completion	      conns_wait;$/;"	m	struct:IS_session	typeref:struct:IS_session::completion
cpu_id	infiniswap.h	/^	int			cpu_id;$/;"	m	struct:IS_connection
cq	infiniswap.h	/^	struct ib_cq *cq;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_cq
createDevice	nbdxadm/nbdxadm	/^def createDevice(parser, opts):$/;"	f
createHost	nbdxadm/nbdxadm	/^def createHost(parser, opts):$/;"	f
created_portals	is_main.c	/^int created_portals = 0;$/;"	v
ctx_list	infiniswap.h	/^	struct rdma_ctx **ctx_list;$/;"	m	struct:free_ctx_pool	typeref:struct:free_ctx_pool::rdma_ctx
ctx_lock	infiniswap.h	/^	spinlock_t ctx_lock;$/;"	m	struct:free_ctx_pool
ctx_pool	infiniswap.h	/^	struct rdma_ctx 	*ctx_pool;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::rdma_ctx
ctx_pool	infiniswap.h	/^	struct rdma_ctx 	*ctx_pool;$/;"	m	struct:ctx_pool_list	typeref:struct:ctx_pool_list::rdma_ctx
ctx_pool_list	infiniswap.h	/^struct ctx_pool_list {$/;"	s
ctx_pools	infiniswap.h	/^	struct ctx_pool_list **ctx_pools;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::ctx_pool_list
cur_weight	infiniswap.h	/^	int cur_weight;$/;"	m	struct:IS_session
data	infiniswap.h	/^	void			*data;  \/* Return in the io completion event *\/$/;"	m	struct:raio_iocb
data_len	infiniswap.h	/^	uint32_t data_len;$/;"	m	struct:raio_answer
data_len	infiniswap.h	/^	uint32_t data_len;$/;"	m	struct:raio_command
deleteDevice	nbdxadm/nbdxadm	/^def deleteDevice(parser, opts):$/;"	f
deleteHost	nbdxadm/nbdxadm	/^def deleteHost(parser, opts):$/;"	f
destroy_conns_count	infiniswap.h	/^	atomic_t		      destroy_conns_count;$/;"	m	struct:IS_session
dev_cg	infiniswap.h	/^	struct config_group	     dev_cg;$/;"	m	struct:IS_file	typeref:struct:IS_file::config_group
dev_name	infiniswap.h	/^	char			     dev_name[MAX_IS_DEV_NAME];$/;"	m	struct:IS_file
device_attr_store	is_configfs.c	/^static ssize_t device_attr_store(struct config_item *item,$/;"	f	file:
device_item_attr	is_configfs.c	/^static struct configfs_attribute device_item_attr = {$/;"	v	typeref:struct:configfs_attribute	file:
devs_list	infiniswap.h	/^	struct list_head	      devs_list; \/* list of struct IS_file *\/$/;"	m	struct:IS_session	typeref:struct:IS_session::list_head
devs_lock	infiniswap.h	/^	spinlock_t		      devs_lock;$/;"	m	struct:IS_session
disk	infiniswap.h	/^	struct gendisk		    *disk;$/;"	m	struct:IS_file	typeref:struct:IS_file::gendisk
dma_mr	infiniswap.h	/^	struct ib_mr *dma_mr;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_mr
evict_chunk_map	infiniswap.h	/^	char *evict_chunk_map;$/;"	m	struct:remote_chunk_g_list
evict_handle_thread	infiniswap.h	/^	struct task_struct *evict_handle_thread;$/;"	m	struct:remote_chunk_g_list	typeref:struct:remote_chunk_g_list::task_struct
evict_handler	is_main.c	/^static int evict_handler(void *data)$/;"	f	file:
fd	infiniswap.h	/^	int			     fd;$/;"	m	struct:IS_file
file_name	infiniswap.h	/^	char			     file_name[MAX_IS_DEV_NAME];$/;"	m	struct:IS_file
fill_sockaddr	is_main.c	/^static void fill_sockaddr(struct sockaddr_storage *sin, struct kernel_cb *cb)$/;"	f	file:
flags	infiniswap.h	/^	unsigned int		flags;$/;"	m	struct:raio_iocb_common
free_chunk_index	infiniswap.h	/^	int free_chunk_index; \/\/active header of unmapped_chunk_list$/;"	m	struct:IS_session
free_ctx_pool	infiniswap.h	/^struct free_ctx_pool {$/;"	s
free_ctxs	infiniswap.h	/^	struct free_ctx_pool *free_ctxs;  \/\/or this one$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::free_ctx_pool
free_ctxs	infiniswap.h	/^	struct free_ctx_pool *free_ctxs;$/;"	m	struct:IS_connection	typeref:struct:IS_connection::free_ctx_pool
free_ctxs	infiniswap.h	/^	struct free_ctx_pool *free_ctxs;$/;"	m	struct:ctx_pool_list	typeref:struct:ctx_pool_list::free_ctx_pool
g_IS_sessions	is_main.c	/^struct list_head g_IS_sessions;$/;"	v	typeref:struct:list_head
g_lock	is_main.c	/^struct mutex g_lock;$/;"	v	typeref:struct:mutex
gd	infiniswap.h	/^    struct gendisk *gd;$/;"	m	struct:stackbd_t	typeref:struct:stackbd_t::gendisk
get_host_devices	nbdxadm/nbdxadm	/^def get_host_devices(host, parser):$/;"	f
head	infiniswap.h	/^	int head;$/;"	m	struct:free_ctx_pool
htonll	infiniswap.h	180;"	d
htonll2	infiniswap.h	182;"	d
in_flight	infiniswap.h	/^	atomic_t in_flight; \/\/true = 1, false = 0$/;"	m	struct:rdma_ctx
index	infiniswap.h	/^	int			     index; \/* drive idx *\/$/;"	m	struct:IS_file
infiniswap-objs	Makefile	/^infiniswap-objs := 	\\$/;"	m
iocb	infiniswap.h	/^	struct raio_iocb		iocb;$/;"	m	struct:raio_io_u	typeref:struct:raio_io_u::raio_iocb
is_active	infiniswap.h	/^    int is_active;$/;"	m	struct:stackbd_t
is_configfs_mounted	nbdxadm/nbdxadm	/^def is_configfs_mounted():$/;"	f
ismodule	Makefile	/^ismodule := infiniswap.ko$/;"	m
ismoduledir	Makefile	/^ismoduledir = \/lib\/modules\/$(shell uname -r)\/extra\/infiniswap$/;"	m
issrc	Makefile	/^issrc := .\/$/;"	m
kernel_cb	infiniswap.h	/^struct kernel_cb {$/;"	s
kernel_cb_init	is_main.c	/^static int kernel_cb_init(struct kernel_cb *cb, struct IS_session *IS_session)$/;"	f	file:
key	infiniswap.h	/^	unsigned int		key;	\/* For use in identifying io requests *\/$/;"	m	struct:raio_iocb
last_ops	infiniswap.h	/^	unsigned long last_ops[STACKBD_SIZE_G];$/;"	m	struct:IS_session
len	infiniswap.h	/^	unsigned int len;$/;"	m	struct:free_ctx_pool
len	infiniswap.h	/^	unsigned long len;$/;"	m	struct:chunk_write
len	infiniswap.h	/^	unsigned long len;$/;"	m	struct:rdma_ctx
list	infiniswap.h	/^	struct list_head		list;$/;"	m	struct:raio_io_u	typeref:struct:raio_io_u::list_head
list	infiniswap.h	/^	struct list_head	      list;$/;"	m	struct:IS_session	typeref:struct:IS_session::list_head
list	infiniswap.h	/^	struct list_head	     list; \/* next node in list of struct IS_file *\/$/;"	m	struct:IS_file	typeref:struct:IS_file::list_head
list	infiniswap.h	/^	struct list_head list;	$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::list_head
local_dma_lkey	infiniswap.h	/^	int local_dma_lkey;		\/* use 0 for lkey *\/$/;"	m	struct:kernel_cb
lock	infiniswap.h	/^    spinlock_t lock;$/;"	m	struct:stackbd_t
main	nbdxadm/nbdxadm	/^def main():$/;"	f
major	infiniswap.h	/^	int			     major; \/* major number from kernel *\/$/;"	m	struct:IS_file
major_num	infiniswap.h	/^static int major_num = 0;$/;"	v
mapped_capacity	infiniswap.h	/^	unsigned long long 	  mapped_capacity;$/;"	m	struct:IS_session
mapped_cb_num	infiniswap.h	/^	int mapped_cb_num;	\/\/How many cbs are remote mapped$/;"	m	struct:IS_session
mem	infiniswap.h	/^	enum mem_type mem;$/;"	m	struct:kernel_cb	typeref:enum:kernel_cb::mem_type
mem_gather	is_main.c	/^void mem_gather(char *rdma_buf, struct request *req)$/;"	f
mem_type	infiniswap.h	/^enum mem_type {$/;"	g
mkdir_p	Makefile	/^mkdir_p = mkdir -p$/;"	m
nbdxadm	Makefile	/^nbdxadm := nbdxadm$/;"	m
nbytes	infiniswap.h	/^	unsigned long long	nbytes;$/;"	m	struct:raio_iocb_common
nr_queues	infiniswap.h	/^	unsigned int		     nr_queues;$/;"	m	struct:IS_file
ntohll	infiniswap.h	178;"	d
ntohll2	infiniswap.h	183;"	d
obj-m	Makefile	/^obj-m := infiniswap.o$/;"	m
offset	infiniswap.h	/^	long long		offset;$/;"	m	struct:raio_iocb_common
offset	infiniswap.h	/^	unsigned long offset;$/;"	m	struct:rdma_ctx
pad	infiniswap.h	/^	int			pad;$/;"	m	struct:raio_iocb
pd	infiniswap.h	/^	struct ib_pd *pd;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_pd
port	infiniswap.h	/^	uint16_t port;			\/* dst port in NBO *\/$/;"	m	struct:IS_portal
port	infiniswap.h	/^	uint16_t port;			\/* dst port in NBO *\/$/;"	m	struct:kernel_cb
portal	infiniswap.h	/^	char			      portal[MAX_PORTAL_NAME];$/;"	m	struct:IS_session
portal_attr_store	is_configfs.c	/^static ssize_t portal_attr_store(struct config_item *citem,$/;"	f	file:
portal_item_attr	is_configfs.c	/^static struct configfs_attribute portal_item_attr = {$/;"	v	typeref:struct:configfs_attribute	file:
portal_list	infiniswap.h	/^	struct IS_portal *portal_list;$/;"	m	struct:IS_session	typeref:struct:IS_session::IS_portal
portal_parser	is_main.c	/^static void portal_parser(struct IS_session *IS_session)$/;"	f	file:
ptr_from_uint64	infiniswap.h	613;"	d
qp	infiniswap.h	/^	struct ib_qp *qp;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_qp
queue	infiniswap.h	/^	struct request_queue	    *queue; \/* The device request queue *\/$/;"	m	struct:IS_file	typeref:struct:IS_file::request_queue
queue	infiniswap.h	/^    struct request_queue *queue;$/;"	m	struct:stackbd_t	typeref:struct:stackbd_t::request_queue
queue_depth	infiniswap.h	/^	unsigned int		     queue_depth;$/;"	m	struct:IS_file
queue_depth	infiniswap.h	/^	unsigned int		     queue_depth;$/;"	m	struct:IS_queue
queues	infiniswap.h	/^	struct IS_queue	    *queues;$/;"	m	struct:IS_file	typeref:struct:IS_file::IS_queue
r_stat64	infiniswap.h	/^struct r_stat64 {$/;"	s
raio_answer	infiniswap.h	/^struct raio_answer {$/;"	s
raio_command	infiniswap.h	/^struct raio_command {$/;"	s
raio_fildes	infiniswap.h	/^	int			raio_fildes;$/;"	m	struct:raio_iocb
raio_io_u	infiniswap.h	/^struct raio_io_u {$/;"	s
raio_iocb	infiniswap.h	/^struct raio_iocb {$/;"	s
raio_iocb_common	infiniswap.h	/^struct raio_iocb_common {$/;"	s
raio_lio_opcode	infiniswap.h	/^	int			raio_lio_opcode;$/;"	m	struct:raio_iocb
rdma_buf	infiniswap.h	/^	char *rdma_buf;			\/* used as rdma sink *\/$/;"	m	struct:kernel_cb
rdma_buf	infiniswap.h	/^	char *rdma_buf;			\/* used as rdma sink *\/$/;"	m	struct:rdma_ctx
rdma_connect_down	is_main.c	/^static int rdma_connect_down(struct kernel_cb *cb)$/;"	f	file:
rdma_connect_upper	is_main.c	/^static int rdma_connect_upper(struct kernel_cb *cb)$/;"	f	file:
rdma_cq_event_handler	is_main.c	/^static void rdma_cq_event_handler(struct ib_cq * cq, void *ctx)$/;"	f	file:
rdma_ctx	infiniswap.h	/^struct rdma_ctx {$/;"	s
rdma_dma_addr	infiniswap.h	/^	u64  rdma_dma_addr;$/;"	m	struct:kernel_cb
rdma_dma_addr	infiniswap.h	/^	u64  rdma_dma_addr;$/;"	m	struct:rdma_ctx
rdma_mr	infiniswap.h	/^	struct ib_mr *rdma_mr;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_mr
rdma_mr	infiniswap.h	/^	struct ib_mr *rdma_mr;$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::ib_mr
rdma_on	infiniswap.h	/^	atomic_t	rdma_on;	\/\/DEV_RDMA_ON\/OFF$/;"	m	struct:IS_session
rdma_sgl	infiniswap.h	/^	struct ib_sge rdma_sgl;		\/* rdma single SGE *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_sge
rdma_sgl	infiniswap.h	/^	struct ib_sge rdma_sgl;		\/* rdma single SGE *\/$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::ib_sge
rdma_sq_wr	infiniswap.h	/^	struct ib_rdma_wr rdma_sq_wr;	\/* rdma work request record *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_rdma_wr
rdma_sq_wr	infiniswap.h	/^	struct ib_rdma_wr rdma_sq_wr;	\/* rdma work request record *\/$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::ib_rdma_wr
rdma_sq_wr	infiniswap.h	/^	struct ib_send_wr rdma_sq_wr;	\/* rdma work request record *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_send_wr
rdma_sq_wr	infiniswap.h	/^	struct ib_send_wr rdma_sq_wr;	\/* rdma work request record *\/$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::ib_send_wr
rdma_trigger	is_main.c	/^static int rdma_trigger(void *data)$/;"	f	file:
rdma_trigger_thread	infiniswap.h	/^	struct task_struct     *rdma_trigger_thread; \/\/based on swap rate$/;"	m	struct:IS_session	typeref:struct:IS_session::task_struct
read_ops	infiniswap.h	/^	unsigned long read_ops[STACKBD_SIZE_G];	$/;"	m	struct:IS_session
read_ops_lock	infiniswap.h	/^	spinlock_t read_ops_lock[STACKBD_SIZE_G];$/;"	m	struct:IS_session
read_request_count	infiniswap.h	/^	unsigned long int *read_request_count;	\/\/how many requests on each CPU$/;"	m	struct:IS_session
recv_buf	infiniswap.h	/^	struct IS_rdma_info recv_buf;\/* malloc'd buffer *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::IS_rdma_info
recv_dma_addr	infiniswap.h	/^	u64 recv_dma_addr;$/;"	m	struct:kernel_cb
recv_mr	infiniswap.h	/^	struct ib_mr *recv_mr;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_mr
recv_sgl	infiniswap.h	/^	struct ib_sge recv_sgl;		\/* recv single SGE *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_sge
redirect_done	infiniswap.h	/^    atomic_t redirect_done;$/;"	m	struct:stackbd_t
remote_addr	infiniswap.h	/^	uint64_t remote_addr;		\/* remote guys TO *\/$/;"	m	struct:remote_chunk_g
remote_chunk	infiniswap.h	/^	struct remote_chunk_g_list remote_chunk;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::remote_chunk_g_list
remote_chunk_g	infiniswap.h	/^struct remote_chunk_g {$/;"	s
remote_chunk_g_list	infiniswap.h	/^struct remote_chunk_g_list {$/;"	s
remote_len	infiniswap.h	/^	uint64_t remote_len;		\/* remote guys LEN *\/$/;"	m	struct:kernel_cb
remote_mapped	infiniswap.h	/^	atomic_t *remote_mapped; $/;"	m	struct:remote_chunk_g_list
remote_rkey	infiniswap.h	/^	uint32_t remote_rkey;		\/* remote guys RKEY *\/$/;"	m	struct:remote_chunk_g
req	infiniswap.h	/^	struct request *req;$/;"	m	struct:rdma_ctx	typeref:struct:rdma_ctx::request
req_hdr	infiniswap.h	/^	char				req_hdr[SUBMIT_HEADER_SIZE];$/;"	m	struct:raio_io_u
req_offset	infiniswap.h	/^	unsigned long req_offset;$/;"	m	struct:chunk_write
res	infiniswap.h	/^	int				res;$/;"	m	struct:raio_io_u
res2	infiniswap.h	/^	int				res2;$/;"	m	struct:raio_io_u
resfd	infiniswap.h	/^	unsigned int		resfd;$/;"	m	struct:raio_iocb_common
ret	infiniswap.h	/^	int32_t ret;$/;"	m	struct:raio_answer
ret_errno	infiniswap.h	/^	int32_t ret_errno;$/;"	m	struct:raio_answer
rkey	infiniswap.h	/^  	uint32_t rkey[MAX_MR_SIZE_GB];$/;"	m	struct:IS_rdma_info
rq_wr	infiniswap.h	/^	struct ib_recv_wr rq_wr;	\/* recv work request record *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_recv_wr
sem	infiniswap.h	/^	wait_queue_head_t sem;      	$/;"	m	struct:remote_chunk_g_list
sem	infiniswap.h	/^	wait_queue_head_t sem;      \/\/ semaphore for wait\/wakeup$/;"	m	struct:kernel_cb
send_buf	infiniswap.h	/^	struct IS_rdma_info send_buf;\/* single send buf *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::IS_rdma_info
send_dma_addr	infiniswap.h	/^	u64 send_dma_addr;$/;"	m	struct:kernel_cb
send_mr	infiniswap.h	/^	struct ib_mr *send_mr;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_mr
send_sgl	infiniswap.h	/^	struct ib_sge send_sgl;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_sge
server	infiniswap.h	/^	int server;			\/* 0 iff client *\/$/;"	m	struct:kernel_cb
session_cg	infiniswap.h	/^	struct config_group	      session_cg;$/;"	m	struct:IS_session	typeref:struct:IS_session::config_group
sgl	infiniswap.h	/^	struct scatterlist  sgl[MAX_SGL_LEN];$/;"	m	struct:raio_io_u	typeref:struct:raio_io_u::scatterlist
showAllDevices	nbdxadm/nbdxadm	/^def showAllDevices(parser, opts):$/;"	f
showAllHosts	nbdxadm/nbdxadm	/^def showAllHosts(parser, opts):$/;"	f
showDevice	nbdxadm/nbdxadm	/^def showDevice(parser, opts):$/;"	f
showHost	nbdxadm/nbdxadm	/^def showHost(parser, opts):$/;"	f
showHostDevices	nbdxadm/nbdxadm	/^def showHostDevices(parser, opts):$/;"	f
shrink_size_g	infiniswap.h	/^	int shrink_size_g;$/;"	m	struct:remote_chunk_g_list
size	infiniswap.h	/^	int size;			\/* ping data size *\/$/;"	m	struct:kernel_cb
size_gb	infiniswap.h	/^  	int size_gb;	$/;"	m	struct:IS_rdma_info
sq_wr	infiniswap.h	/^	struct ib_send_wr sq_wr;	\/* send work requrest record *\/$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_send_wr
st_size	infiniswap.h	/^    uint64_t     st_size;    \/* total size, in bytes *\/$/;"	m	struct:r_stat64
stackbd	infiniswap.h	/^} stackbd;$/;"	v	typeref:struct:stackbd_t
stackbd_bdev_open	is_mq.c	/^static struct block_device *stackbd_bdev_open(char dev_path[])$/;"	f	file:
stackbd_bio_generate	is_main.c	/^void stackbd_bio_generate(struct rdma_ctx *ctx, struct request *req)$/;"	f
stackbd_getgeo	is_mq.c	/^int stackbd_getgeo(struct block_device * block_device, struct hd_geometry * geo)$/;"	f
stackbd_io_fn	is_mq.c	/^static void stackbd_io_fn(struct bio *bio)$/;"	f	file:
stackbd_make_request	is_mq.c	/^blk_qc_t stackbd_make_request(struct request_queue *q, struct bio *bio)$/;"	f
stackbd_make_request2	is_mq.c	/^void stackbd_make_request2(struct request_queue *q, struct request *req)$/;"	f
stackbd_make_request3	is_mq.c	/^void stackbd_make_request3(struct request_queue *q, struct request *req)$/;"	f
stackbd_make_request4	is_mq.c	/^void stackbd_make_request4(struct request_queue *q, struct request *req)$/;"	f
stackbd_make_request5	is_mq.c	/^void stackbd_make_request5(struct bio *bio)$/;"	f
stackbd_ops	is_mq.c	/^static struct block_device_operations stackbd_ops = {$/;"	v	typeref:struct:block_device_operations	file:
stackbd_start	is_mq.c	/^static int stackbd_start(char dev_path[])$/;"	f	file:
stackbd_t	infiniswap.h	/^static struct stackbd_t {$/;"	s
stackbd_threadfn	is_mq.c	/^static int stackbd_threadfn(void *data)$/;"	f	file:
start_buf	infiniswap.h	/^	char *start_buf;		\/* rdma read src *\/$/;"	m	struct:kernel_cb
start_dma_addr	infiniswap.h	/^	u64  start_dma_addr;$/;"	m	struct:kernel_cb
start_mr	infiniswap.h	/^	struct ib_mr *start_mr;$/;"	m	struct:kernel_cb	typeref:struct:kernel_cb::ib_mr
state	infiniswap.h	/^	enum IS_dev_state	     state;	$/;"	m	struct:IS_file	typeref:enum:IS_file::IS_dev_state
state	infiniswap.h	/^	enum test_state state;		\/* used for cond\/signalling *\/$/;"	m	struct:kernel_cb	typeref:enum:kernel_cb::test_state
state_attr_show	is_configfs.c	/^static ssize_t state_attr_show(struct config_item *item,$/;"	f	file:
state_item_attr	is_configfs.c	/^static struct configfs_attribute state_item_attr = {$/;"	v	typeref:struct:configfs_attribute	file:
state_lock	infiniswap.h	/^	spinlock_t		     state_lock;$/;"	m	struct:IS_file
stbuf	infiniswap.h	/^	struct r_stat64		     stbuf; \/* remote file stats*\/$/;"	m	struct:IS_file	typeref:struct:IS_file::r_stat64
submit_queues	is_main.c	/^int submit_queues; \/\/ num of available cpu (also connections)$/;"	v
tag_set	infiniswap.h	/^	struct blk_mq_tag_set	     tag_set;$/;"	m	struct:IS_file	typeref:struct:IS_file::blk_mq_tag_set
tail	infiniswap.h	/^	int tail;$/;"	m	struct:free_ctx_pool
target_size_g	infiniswap.h	/^	int target_size_g; \/\/ == future size of remote$/;"	m	struct:remote_chunk_g_list
test_state	infiniswap.h	/^enum test_state { $/;"	g
thread	infiniswap.h	/^    struct task_struct *thread;$/;"	m	struct:stackbd_t	typeref:struct:stackbd_t::task_struct
trigger_enable	infiniswap.h	/^	atomic_t trigger_enable;$/;"	m	struct:IS_session
trigger_threshold	infiniswap.h	/^	unsigned long trigger_threshold;$/;"	m	struct:IS_session
txdepth	infiniswap.h	/^	int txdepth;			\/* SQ depth *\/$/;"	m	struct:kernel_cb
type	infiniswap.h	/^	} type;$/;"	m	struct:IS_rdma_info	typeref:enum:IS_rdma_info::__anon2
u	infiniswap.h	/^	} u;$/;"	m	struct:raio_iocb	typeref:union:raio_iocb::__anon1
uint64_from_ptr	infiniswap.h	612;"	d
unmapped_chunk_list	infiniswap.h	/^	int *unmapped_chunk_list;$/;"	m	struct:IS_session
verbose	infiniswap.h	/^	int verbose;			\/* verbose logging *\/$/;"	m	struct:kernel_cb
w_weight	infiniswap.h	/^	int w_weight;$/;"	m	struct:IS_session
wq	infiniswap.h	/^	wait_queue_head_t	wq;$/;"	m	struct:IS_connection
wq_flag	infiniswap.h	/^	int			wq_flag;$/;"	m	struct:IS_connection
write_ops	infiniswap.h	/^	unsigned long write_ops[STACKBD_SIZE_G];$/;"	m	struct:IS_session
write_ops_lock	infiniswap.h	/^	spinlock_t write_ops_lock[STACKBD_SIZE_G];$/;"	m	struct:IS_session
write_request_count	infiniswap.h	/^	unsigned long int *write_request_count;	\/\/how many requests on each CPU$/;"	m	struct:IS_session
xdev	infiniswap.h	/^	struct IS_file	    *xdev; \/* pointer to parent*\/$/;"	m	struct:IS_queue	typeref:struct:IS_queue::IS_file
xdev	infiniswap.h	/^	struct IS_file 		*xdev;	\/\/ each session only creates a single IS_file$/;"	m	struct:IS_session	typeref:struct:IS_session::IS_file
